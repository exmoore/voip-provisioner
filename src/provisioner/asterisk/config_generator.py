"""Generate Asterisk configuration files from inventory."""

import logging
from pathlib import Path

from jinja2 import Environment, FileSystemLoader

from ..config import AsteriskConfig
from ..inventory import Inventory
from .ami_client import AMIClient

logger = logging.getLogger("provisioner.asterisk.config")


class AsteriskConfigGenerator:
    """Generates Asterisk pjsip.conf and extensions.conf from phone inventory."""

    def __init__(self, templates_dir: Path, config: AsteriskConfig):
        """Initialize config generator.

        Args:
            templates_dir: Base templates directory
            config: Asterisk configuration
        """
        self.config = config
        asterisk_templates = templates_dir / "asterisk"

        # Setup Jinja2 environment
        self.env = Environment(
            loader=FileSystemLoader(str(asterisk_templates)),
            trim_blocks=True,
            lstrip_blocks=True,
        )

    def generate_pjsip_conf(self, inventory: Inventory) -> str:
        """Generate complete pjsip.conf with all phone endpoints.

        Args:
            inventory: Phone inventory

        Returns:
            Generated pjsip.conf content
        """
        sections = []

        # Add header comment
        sections.append(
            "; PJSIP Configuration\n"
            "; Auto-generated by VOIP Provisioner\n"
            "; DO NOT EDIT - Changes will be overwritten\n"
        )

        for phone in inventory.phones:
            settings = inventory.get_effective_settings(phone)

            # Generate endpoint section
            endpoint = self.env.get_template("pjsip_endpoint.conf.j2").render(
                extension=phone.extension,
                display_name=phone.display_name,
                context=self.config.context,
                transport=self.config.transport,
                codecs=",".join(settings["codecs"]).lower(),  # Asterisk uses lowercase
            )
            sections.append(endpoint)

            # Generate auth section
            auth = self.env.get_template("pjsip_auth.conf.j2").render(
                extension=phone.extension,
                password=phone.password,
            )
            sections.append(auth)

            # Generate AOR section
            aor = self.env.get_template("pjsip_aor.conf.j2").render(
                extension=phone.extension,
            )
            sections.append(aor)

        return "\n".join(sections)

    def generate_extensions_conf(self, inventory: Inventory) -> str:
        """Generate extensions.conf dialplan entries.

        Args:
            inventory: Phone inventory

        Returns:
            Generated extensions.conf content
        """
        entries = []

        # Add header
        entries.append(
            "; Extensions Configuration\n"
            f"; Context: {self.config.context}\n"
            "; Auto-generated by VOIP Provisioner\n"
            "; DO NOT EDIT - Changes will be overwritten\n"
        )

        # Add context header
        entries.append(f"[{self.config.context}]")

        for phone in inventory.phones:
            entry = self.env.get_template("extensions_entry.conf.j2").render(
                extension=phone.extension,
                display_name=phone.display_name,
            )
            entries.append(entry)

        return "\n".join(entries)

    async def write_and_reload(
        self, inventory: Inventory, ami_client: AMIClient | None = None
    ) -> dict[str, bool]:
        """Generate configs, write to Asterisk server, and reload.

        Args:
            inventory: Phone inventory
            ami_client: AMI client instance (if None, creates new one)

        Returns:
            Dict with status of each operation: {
                "pjsip_written": bool,
                "extensions_written": bool,
                "pjsip_reloaded": bool,
                "dialplan_reloaded": bool,
                "success": bool
            }
        """
        result = {
            "pjsip_written": False,
            "extensions_written": False,
            "pjsip_reloaded": False,
            "dialplan_reloaded": False,
            "success": False,
        }

        try:
            # Generate configs
            pjsip_conf = self.generate_pjsip_conf(inventory)
            extensions_conf = self.generate_extensions_conf(inventory)

            # Write to files
            # Note: Assumes shared filesystem or Docker volume
            pjsip_path = Path(self.config.pjsip_config_path)
            extensions_path = Path(self.config.extensions_config_path)

            # Create parent directories if they don't exist
            pjsip_path.parent.mkdir(parents=True, exist_ok=True)
            extensions_path.parent.mkdir(parents=True, exist_ok=True)

            # Write files
            pjsip_path.write_text(pjsip_conf)
            result["pjsip_written"] = True
            logger.info(f"Wrote pjsip.conf to {pjsip_path}")

            extensions_path.write_text(extensions_conf)
            result["extensions_written"] = True
            logger.info(f"Wrote extensions.conf to {extensions_path}")

            # Reload via AMI if client provided
            if ami_client:
                # Connect if not already connected
                if not await ami_client.connect():
                    logger.error("Failed to connect to AMI for reload")
                    return result

                # Reload PJSIP
                pjsip_ok = await ami_client.execute_with_retry(
                    "PJSIP reload", ami_client.reload_pjsip
                )
                result["pjsip_reloaded"] = pjsip_ok

                # Reload dialplan
                dialplan_ok = await ami_client.execute_with_retry(
                    "Dialplan reload", ami_client.reload_dialplan
                )
                result["dialplan_reloaded"] = dialplan_ok

                result["success"] = pjsip_ok and dialplan_ok

                # Disconnect
                await ami_client.disconnect()
            else:
                # No AMI client, consider write success as overall success
                result["success"] = True
                logger.warning("No AMI client provided, skipping Asterisk reload")

            return result

        except Exception as e:
            logger.error(f"Asterisk config write/reload failed: {e}")
            result["success"] = False
            return result

    def generate_single_endpoint(
        self, extension: str, display_name: str, password: str, codecs: list[str]
    ) -> str:
        """Generate PJSIP config for a single endpoint (for testing/debugging).

        Args:
            extension: Extension number
            display_name: Display name
            password: SIP password
            codecs: List of codec names

        Returns:
            Combined pjsip.conf sections for this endpoint
        """
        sections = []

        endpoint = self.env.get_template("pjsip_endpoint.conf.j2").render(
            extension=extension,
            display_name=display_name,
            context=self.config.context,
            transport=self.config.transport,
            codecs=",".join(codecs).lower(),
        )
        sections.append(endpoint)

        auth = self.env.get_template("pjsip_auth.conf.j2").render(
            extension=extension,
            password=password,
        )
        sections.append(auth)

        aor = self.env.get_template("pjsip_aor.conf.j2").render(
            extension=extension,
        )
        sections.append(aor)

        return "\n".join(sections)
